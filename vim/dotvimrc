set nu
syn on
set mouse=a
set smartindent
set autoindent
set ttymouse=xterm2
set encoding=utf-8
colorscheme Tomorrow-Night
set t_Co=256
set listchars=tab:·\ ,eol:¬
set statusline=%<\ %n:%f\ %m%r%y%=%-40.([%{&expandtab?'space':'tab'}]\ line:\ %l\ of\ %L,\ col:\ %c%V\ (%P)%)
set laststatus=2
set showmatch
set incsearch
set hlsearch
set list
let mapleader=','
set history=10000
set ignorecase smartcase
set cursorline
set cmdheight=2
set winwidth=79

" store temporary file in central directory
set backup
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp


" vundle
set nocompatible
filetype off

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

" let Vundle manage Vundle, required
Plugin 'gmarik/Vundle.vim'

Plugin 'scrooloose/nerdtree'
Plugin 'vim-scripts/Align'
Plugin 'lukaszb/vim-web-indent'
Plugin 'tpope/vim-surround'
Plugin 'tpope/vim-rails'
Plugin 'tpope/vim-endwise'
Plugin 'kchmck/vim-coffee-script'
Plugin 'tpope/vim-fugitive'
Plugin 'wincent/Command-T'
Plugin 'rking/ag.vim'
Plugin 'tpope/vim-unimpaired'
Plugin 'vim-ruby/vim-ruby'
Plugin 'groenewege/vim-less'
Plugin 'kana/vim-textobj-user'
Plugin 'nelstrom/vim-textobj-rubyblock'
Plugin 'editorconfig/editorconfig-vim'
Plugin 'scrooloose/syntastic'
Plugin 'fatih/vim-go'

" Golang Plugins
Plugin 'Valloric/YouCompleteMe'
Plugin 'majutsushi/tagbar'
Plugin 'SirVer/ultisnips'
Plugin 'yulrizka/vim-snippets'

let g:UltiSnipsExpandTrigger="<c-l>"
let g:UltiSnipsJumpForwardTrigger="<c-b>"
let g:UltiSnipsJumpBackwardTrigger="<c-z>"

call vundle#end()
filetype plugin indent on

" restor cursor position
autocmd BufReadPost *
      \ if line("'\"") > 1 && line("'\"") <= line("$") |
      \   exe "normal! g`\"" |
      \ endif

" virtual tabstops using spaces
set tabstop=2
set softtabstop=2
set shiftwidth=2
set expandtab

syntax on

" scroll
set scrolloff=3

"window commands
map <C-h> <C-w>h
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-l> <C-w>l

inoremap <s-tab> <c-n>

" Function to toogle vertical line
nnoremap <silent> <leader>vl :set cursorcolumn!<CR>

"map <F2> :NERDTreeToggle<CR>
set pastetoggle=<F3>
map <F5> <Esc>:EnableFastPHPFolds<CR>:let g:DisableAutoPHPFolding = 0<CR>
map <F6> <Esc>:EnablePHPFolds<CR>:let g:DisableAutoPHPFolding = 0<CR>
map <F7> <Esc>:DisablePHPFolds<CR>:let g:DisableAutoPHPFolding = 1<CR>
nmap <F9> :set expandtab!<CR>
map  <F12> :set hls!<CR>
imap <F12> <ESC>:set hls!<CR>a
vmap <F12> <ESC>:set hls!<CR>gv

" folding
nnoremap <Space> za
vnoremap <Space> za

nnoremap <silent> <C-n>      :FufBuffer<CR>
nnoremap <silent> <C-p>      :FufFileWithCurrentBufferDir<CR>
nnoremap <silent> <C-f><C-p> :FufFileWithFullCwd<CR>
nnoremap <silent> <C-f>p     :FufFile<CR>

"tab commands
map <C-S-]> gt
map <C-S-[> gT
map <C-1> 1gt
map <C-2> 2gt
map <C-3> 3gt
map <C-4> 4gt
map <C-5> 5gt
map <C-6> 6gt
map <C-7> 7gt
map <C-8> 8gt
map <C-9> 9gt
map <C-0> :tablast<CR>

"Commands
command! W w !sudo tee % > /dev/null
command! -range=% CheckWhitespace <line1>,<line2>s/\s\+$//gc
command! Q q

"save
map <leader>s :w<CR>
imap <leader>s <esc>:w<CR>

map <c-s> :w<CR>
imap <c-s>s <esc>:w<CR>

" If the current buffer has never been saved, it will have no name,
" call the file browser to save it, otherwise just save it.
command -nargs=0 -bar Update if &modified
                           \|    if empty(bufname('%'))
                           \|        browse confirm write
                           \|    else
                           \|        confirm write
                           \|    endif
                           \|endif
noremap <silent> <C-S> :<C-u>Update<CR>
inoremap <silent> <C-S> <esc>:<C-u>Update<CR>


" delete without yanking
nnoremap <leader>d "_d
vnoremap <leader>d "_d
nnoremap <leader>D "_D
vnoremap <leader>D "_D

" replace currently selected text with default register
" without yanking it
vnoremap <leader>p "_dP

nnoremap <leader>= :Align<CR>
vnoremap <leader>= :Align<CR>

" Copy paste from clipboard (xclip) must be enabled
vmap "+y :!xclip -f -sel clip<CR>
map "+p :!xclip -o -sel clip<CR>
"Plugins and phatogen
call pathogen#infect()

" Can't be bothered to understand ESC vs <c-c> in insert mode
imap <c-c> <esc>
" Clear the search buffer when hitting return
function! MapCR()
  nnoremap <cr> :nohlsearch<cr>
endfunction
call MapCR()
nnoremap <leader><leader> <c-^>

""
" FUNCTIONS
""
" toogle list and nolist character
function! ListToggle()
	if &list
		set nolist
		echo 'nolist'
	else
		set list
		echo 'list'
	endif
endfunction
nnoremap <silent> <leader>l :call ListToggle()<CR>

" Highlight trailing spaces
highlight ExtraWhitespace ctermbg=red guibg=red
let g:highlightWhitespace = 2
function! g:ToggleHighlightWhitespace()
  if g:highlightWhitespace == 2
    let g:highlightWhitespace = 0
    match ExtraWhitespace //
  elseif g:highlightWhitespace == 0
    let g:highlightWhitespace = 1
    match ExtraWhitespace /\S\zs\s\+$/
  elseif g:highlightWhitespace == 1
    let g:highlightWhitespace = 2
    match ExtraWhitespace /\s\+$/
  endif
endfunction
call g:ToggleHighlightWhitespace()
nnoremap <silent> <leader>hw :call g:ToggleHighlightWhitespace()<CR>

call g:ToggleHighlightWhitespace()

" Function to toggle color column
highlight OverLength ctermbg=red ctermfg=white guibg=#592929
function! g:ToggleColorColumn()
  if &colorcolumn != ''
    setlocal colorcolumn&
		match OverLength //
  else
    setlocal colorcolumn=80
		match OverLength /\%121v.*/
  endif
endfunction
nnoremap <silent> <leader>cc :call g:ToggleColorColumn()<CR>

"Fuzzy finder binding
let g:fuf_modesDisable = []
let g:fuf_mrufile_maxItem = 1000
let g:fuf_mrucmd_maxItem = 400
let g:fuf_mrufile_exclude = '\v\~$|\.(bak|sw[po])$|^(\/\/|\\\\|\/mnt\/)'

if $TERM =~ '^screen-256color'
    map <Esc>OH <Home>
    map! <Esc>OH <Home>
    map <Esc>OF <End>
    map! <Esc>OF <End>
endif

" Fugitive
autocmd User Fugitive
      \ if fugitive#buffer().type() =~# '^\%(tree\|blob\)$' |
      \   nnoremap <buffer> .. :edit %:h<CR> |
      \ endif

autocmd BufReadPost fugitive://* set bufhidden=delete

" ctags
let Tlist_Ctags_Cmd = "/usr/bin/ctags"
let Tlist_WinWidth = 50
map <F4> :TlistToggle<cr>


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" RUNNING TESTS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
map <leader>t :call RunTestFile()<cr>
map <leader>T :call RunNearestTest()<cr>
map <leader>a :call RunTests('')<cr>
map <leader>l :call RunLastTest()<cr>
map <leader>c :w\|:!script/features<cr>
map <leader>w :w\|:!script/features --profile wip<cr>

let t:minitest = 0

function! RunTestFile(...)
    if a:0
        let t:command_suffix = a:1
    else
        let t:command_suffix = ""
    endif

    " Run the tests for the previously-marked file.
    let in_test_file = match(expand("%"), '\(.feature\|_spec.rb\)$') != -1
    if in_test_file
        call SetTestFile()
    elseif !exists("t:grb_test_file")
        return
    end

    let last_text_command = t:grb_test_file . t:command_suffix
    call RunTests(last_text_command)
endfunction

function! RunLastTest()
    call RunTests(t:grb_test_file . t:command_suffix)
endfunction

function! RunNearestTest()
    let spec_line_number = line('.')
    if t:minitest
      call RunTestFile(" -l" . spec_line_number)
    else
      call RunTestFile(":" . spec_line_number . " -b")
    end
endfunction

function! SetTestFile()
    " Set the spec file that tests will be run for.
    let t:grb_test_file=@%
endfunction

function! RunTests(filename)
    " Write the file and run tests for the given filename
    :w
    :silent !echo;echo;echo;echo;echo;echo;echo;echo;echo;echo
    :silent !echo;echo;echo;echo;echo;echo;echo;echo;echo;echo
    :silent !echo;echo;echo;echo;echo;echo;echo;echo;echo;echo
    :silent !echo;echo;echo;echo;echo;echo;echo;echo;echo;echo
    :silent !echo;echo;echo;echo;echo;echo;echo;echo;echo;echo
    :silent !echo;echo;echo;echo;echo;echo;echo;echo;echo;echo
    if match(a:filename, '\.feature$') != -1
        exec ":!script/features " . a:filename
    else
        if filereadable("script/test")
            exec ":!script/test " . a:filename
        elseif t:minitest
            exec ":!bundle exec ruby " . a:filename
        elseif filereadable("Gemfile") && filereadable("bin/rspec")
            echo "e"
            "exec ":!bundle exec rspec --color " . a:filename
            exec ":!bin/rspec --color " . a:filename
        else
            exec ":!rspec --color " . a:filename
        end
    end
endfunction

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CommandT
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
cnoremap %% <C-R>=expand('%:h').'/'<cr>
map <leader>f :CommandTFlush<cr>\|:CommandT<cr>
map <leader>F :CommandTFlush<cr>\|:CommandT %%<cr>
map <leader>b :CommandTBuffer<cr>
set wildignore+=node_modules,Godeps/_workspace

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SWITCH BETWEEN TEST AND PRODUCTION CODE
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! OpenTestAlternate()
  let new_file = AlternateForCurrentFile()
  exec ':e ' . new_file
endfunction
function! AlternateForCurrentFile()
  let current_file = expand("%")
  let new_file = current_file
  let in_spec = match(current_file, '^spec/') != -1
  let going_to_spec = !in_spec
  let in_app = match(current_file, '\<controllers\>') != -1 || match(current_file, '\<models\>') != -1 || match(current_file, '\<views\>') != -1 || match(current_file, '\<helpers\>') != -1 || match(current_file, '\<services\>') != -1
  if going_to_spec
    if in_app
      let new_file = substitute(new_file, '^app/', '', '')
    end
    let new_file = substitute(new_file, '\.rb$', '_spec.rb', '')
    let new_file = 'spec/' . new_file
  else
    let new_file = substitute(new_file, '_spec\.rb$', '.rb', '')
    let new_file = substitute(new_file, '^spec/', '', '')
    if in_app
      let new_file = 'app/' . new_file
    end
  endif
  return new_file
endfunction
nnoremap <leader>. :call OpenTestAlternate()<cr>

""""""""""""""""""""""""""""""""""
" COPY QuickFix list to buffer
"""""""""""""""""""""""""""""""""
command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
function! QuickfixFilenames()
  " Building a hash ensures we get each buffer only once
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction

""""""""""""""""""""""""""""""""
" Copy ARG list
""""""""""""""""""""""""""""""""
command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
function! QuickfixFilenames()
  " Building a hash ensures we get each buffer only once
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction

""
" Undo
""
set undodir=~/.vim/undodir
set undofile
set undolevels=10000
set undoreload=10000

runtime macros/matchit.vim

""
let g:go_fmt_command = "goimports"

